# شمارنده نمایشگر سون سگمنت با ATmega32

این پروژه یک شمارنده دیجیتالی ساده با استفاده از میکروکنترلر ATmega32 و نمایشگر سون سگمنت را نشان می‌دهد. شمارنده اعداد 0 تا 9 را نمایش می‌دهد و هر بار با فشار دکمه، عدد افزایش می‌یابد. پس از رسیدن به عدد 9، شمارنده به 0 بازنشانی می‌شود.

## توضیحات مدار

مدار شامل اجزای زیر است:

- **میکروکنترلر ATmega32:** وظیفه کنترل نمایشگر سون سگمنت را دارد و سیگنال‌های لازم برای روشن کردن بخش‌های درست جهت نمایش هر عدد را ارسال می‌کند.

- **نمایشگر سون سگمنت:** یک نمایشگر کاتد مشترک است که برای نمایش اعداد 0 تا 9 استفاده می‌شود.

- **مقاومت‌ها (10kΩ):** به عنوان مقاومت‌های کششی (Pull-up) برای تضمین سیگنال‌های ورودی پایدار از دکمه به کار می‌روند.

- **خازن (10µF):** برای پایدارسازی و فیلتر کردن توان استفاده می‌شود.

- **دکمه فشاری:** برای افزایش شمارش استفاده می‌شود. هر بار فشار، سیگنالی به میکروکنترلر ارسال می‌کند تا عدد نمایش داده شده افزایش یابد.

## نقشه مدار

نقشه مدار به صورت زیر است:

![نقشه مدار](Screenshot%2024-07-26%180738.png)
## توضیح کد

برنامه به زبان C نوشته شده و از AVR-GCC برای کامپایل و بارگذاری بر روی میکروکنترلر ATmega32 استفاده می‌کند. ویژگی‌های اصلی کد شامل موارد زیر است:

- **راه‌اندازی اولیه:** پورت‌های I/O متصل به نمایشگر سون سگمنت را به عنوان خروجی تنظیم می‌کند و ورودی دکمه را با مقاومت کششی (Pull-up) پیکربندی می‌کند.

- **حلقه اصلی:** به صورت مداوم بررسی می‌کند که آیا دکمه فشار داده شده است. در هر بار فشار، شمارنده افزایش می‌یابد و مقدار جدید روی نمایشگر سون سگمنت نمایش داده می‌شود. اگر شمارنده بیش از 9 شد، به 0 بازنشانی می‌شود.

- **تابع نمایش:** از یک جدول جستجو برای تعیین بخش‌هایی که باید برای هر عدد روشن شوند، استفاده می‌کند.

## نمونه کد

```c


// تعریف بایت‌های بخش
const uint8_t segment_map[] = {
    0b00111111, // 0
    0b00000110, // 1
    0b01011011, // 2
    0b01001111, // 3
    0b01100110, // 4
    0b01101101, // 5
    0b01111101, // 6
    0b00000111, // 7
    0b01111111, // 8
    0b01101111  // 9
};

int main(void) {
    uint8_t number = 0;
    
    // تنظیم بخش‌ها به عنوان خروجی
    DDRC = 0xFF; // فرض بر این است که PORTC به سون سگمنت متصل است
    // تنظیم پین دکمه به عنوان ورودی
    DDRD &= ~(1 << PD2); // فرض بر این است که PD2 ورودی دکمه است
    PORTD |= (1 << PD2); // فعال‌سازی مقاومت کششی روی PD2

    while (1) {
        // بررسی فشار دکمه
        if (!(PIND & (1 << PD2))) {
            // تاخیر برای حذف نویز
            _delay_ms(50);
            // انتظار تا آزاد شدن دکمه
            while (!(PIND & (1 << PD2)));
            _delay_ms(50);
            
            // افزایش عدد
            number++;
            if (number > 9) {
                number = 0;
            }
            
            // نمایش عدد
            PORTC = segment_map[number];
        }
    }
    return 0;
}
